#
# This is a Shiny web application. You can run the application by clicking
# the 'Run App' button above.
#
# Find out more about building applications with Shiny here:
#
#    http://shiny.rstudio.com/
#

pacman::p_load(shiny, shinythemes, tidyverse, rpart,rpart.plot, shinyWidgets)

set.seed(123)


# loading data
hotel_data <- read.csv('data/hotel.csv')

# split train and test
data_size=nrow(hotel_data)
index <- sample(1:data_size, size = trunc(.8 * data_size))
train_df <- hotel_data %>%
  filter(row_number() %in% index)

test_df <- hotel_data %>%
  filter(!(row_number() %in% index))

var_list <- colnames(hotel_data)[3:33]
var_list_default <- var_list[1:3]


### --------- functions
makeTree = function(model_vars, min_split, min_bucket, max_depth) {
  # Takes a list of model variables (strings), a minimum split parameter
  # (int), a minimum bucket size parameter (int), and a maximum tree depth
  # parameter (int) as inputs and then returns an rpart classification tree
  # created with those parameters using Gini-indexes without any pruning.
  
  train_dat = train_df
  # create an rpart compatible formula for the model from the chosen vars
  f = paste("IsCanceled ~ ", paste(model_vars, collapse = " + "))
  # rpart is performs the split calculations and returns the tree
  tree = rpart(
    as.formula(f),
    method = "class",  # sets it up as a classification problem
    data = train_dat,
    parms = list(split = "gini"),  # ensures rpart uses gini indexes
    minsplit = min_split,
    minbucket = min_bucket,
    maxdepth = max_depth,
    cp = 0  # complexity parameter, at zero prevents pruning on branches
  )
  
  return(tree)
}

useTree = function(tree,df) {
  # Takes a tree generated by rpart and a filename (string) as input and
  # then predicts the labels of the data in that file using the tree. It
  # returns a dataframe with two bool (0,1) columns: prediction and truth.
  
  data = df
  prediction = predict(tree, data, type = "class")
  results = as.data.frame(prediction)
  results$truth = data$IsCanceled
  
  return(results)
}

# Evaluation
calcScores = function(results) {
  # Takes a results dataframe as input and then calculates scores for
  # accuracy, true negative rate, and true positive rate. It returns a
  # list of formatted strings detailing these results.
  
  results = table(results)
  
  accuracy <- (sum(diag(results)) / sum(results))*100
  precision <- (diag(results) / colSums(results))
  recall <- (diag(results) / rowSums(results))
  
  # the collapse argument removes the spacing which would otherwise be there
  return(list(
    paste(c("Overall Accuracy: ",   round(accuracy), "%"), collapse = ""),
    paste(c("Precision: ", round(precision), "%"), collapse = ""),
    paste(c("Recall: ", round(recall), "%"), collapse = "")
  ))
}

# Confusion Matrix
resultsTable = function(results) {

  data = table(results)
  Outcomes = c("Predicted Not Cancelled", "Predicted Cancelled", "Total")
  # reconstruct the columns of R's table(...) CLI display
  c1 = c(data[, 1], sum(data[, 1]))  # data[, 1] is a length 2 vector
  c2 = c(data[, 2], sum(data[, 1]))  # data[, 2] is a length 2 vector
  c3 = c(sum(data[, 1]), sum(data[2, ]), sum(data))
  
  # turn these columns back into a dataframe but with proper headers
  output = data.frame(Outcomes)
  output$"Actually Not Cancelled" = c1
  output$"Actually Cancelled" = c2
  output$"Total" = c3
  
  return(output)
}


# ------- Shiny UI --------

ui <- navbarPage(
  title = "Hotel Data Analytical Dashboard",
  fluid = TRUE,
  theme='simplex',
  id = "navbarID",
  
  tabPanel("User Guide",
           icon = icon('person-chalkboard'),
           h1("Welcome to our App!"),
           mainPanel(
             tags$a(href="https://github.com/mtlmh34/Visual-Analytics-Grp-Project/blob/main/README.md", "Click Here for user guide!")
             )
           ),
  
  ######### Page 1
  navbarMenu("Know Your Business", 
             icon = icon('briefcase'),
             tabPanel("Rates",
                      ),
             tabPanel("Cancellations",
                      ),
             tabPanel("Revenue",
                      )
  ),
  
  ######### Page 2
  navbarMenu("Know Your Customers",
             icon = icon('address-card'),
             tabPanel("Demographics",
                      ),
             tabPanel("Preference",
             )
  ),

  ######### Page 3
  navbarMenu("Predictive Analysis", 
             icon = icon("chart-line"),
             tabPanel("Predict For Cancellation: Decision Tree",
                      sidebarLayout(
                        sidebarPanel(
                          h2("The Controls"),
                          br(),
            
                          actionButton(
                            inputId = "createModel",
                            label = "Create Model",
                            class = "btn-primary"  # makes it blue!
                          ),
                          actionButton(
                            inputId = "testModel",
                            label = "Test Model",
                            class = "btn-danger"  # makes it red!
                          ),
                          
                          br(),
                          
                          h3("Model Features"),
                          helpText(
                            'tryna tune it.......'
                          ),
                          pickerInput(
                            inputId = "model_vars",
                            label = NULL,  # label given in outer code
                            choices = var_list,
                            selected = var_list_default,
                            options = list(`actions-box` = TRUE),
                            multiple = TRUE
                          ),
                          
                          br(),
                          
                          h3("Decision Tree"),
                          helpText(
                            "some text..."
                          ),
                          br(),
                          h4("Minimum Split"),
                          helpText(
                            "If at a given node N is below this value, that node cannot",
                            "be split any further: it is a terminal node of the tree."
                          ),
                          sliderInput(
                            inputId = "min_split",
                            label = NULL,  # label given in outer code
                            min = 2,       # two is the smallest that could be split
                            max = 10,      # chosen to not make the models too wild
                            value = 2      # defaults to not having an artifical minimum
                          ),
                          
                          br(),
                          
                          h4("Minimum Bucket Size"),
                          helpText(
                            "If creating a given split would cause N₁ or N₂ to fall below",
                            "this minimum, then that split isn't made part of the",
                            "decision tree."
                          ),
                          sliderInput(
                            inputId = "min_bucket",
                            label = NULL,  # label given in outer code
                            min = 1,       # can't have buckets of size zero
                            max = 30,      # rpart default is minbucket = 3*minsplit
                            value = 1     # defaults to not having an artifical minimum
                          ),
                          br(),
                          h4("Maximum Tree Depth"),
                          helpText(
                            "Control the maximum depth that the decision tree can reach.",
                            "Note that, depending on what features are being used and the",
                            "values of the other parameters, you may end up with a tree",
                            "much shallower than the maximum."
                          ),
                          sliderInput(
                            inputId = "max_depth",
                            label = NULL,  # label given in outer code
                            min = 2,       # a min of 2 allows for at least one split
                            max = 30,      # rpart can't do 31+ depth on 32-bit machines
                            value = 5      # chosen to not make the default too wild
                          )
                        )
                        ,
                        mainPanel(
                          fluidRow(
                            label = NULL,
                            column(6,
                                   h2("Training Results"),
                                   helpText(
                                     ""
                                   ),
                                   # training accuracy, true positive, and true negative
                                   tagAppendAttributes(
                                     textOutput("training_scores"),
                                     # allow linebreaks between scores, larger font here
                                     style = "white-space: pre-wrap; font-size: 17px;"
                                   ),
                                   br(),
                                   # training results table matches layout from presentation
                                   tableOutput("training_table")
                            ), # column
                            column(6,
                                   h2("Test Results"),
                                   helpText(
                                     ""
                                   ), 
                                   # test accuracy, true positive, and true negative
                                   tagAppendAttributes(
                                     textOutput("test_scores"),
                                     # allow linebreaks between scores, larger font here
                                     style = "white-space: pre-wrap; font-size: 17px;"
                                   ),
                                   br(),
                                   # training results table matches layout from presentation
                                   tableOutput("test_table")
                            ) # column
                          ), # fluidRow
                          h2("Decision Tree"),
                          helpText(
                            "This is a graphical depiction of the decision tree, the model"
                          ),
                          plotOutput(outputId = "tree_plot"),
                          br(),
                          
                        ) # MainPanel
                      ) # SidebarLayout
                ), # tabPanel
             tabPanel("Predict For Cancellation: Logistic Regression")
             
          )
)
                                       

# ------- server --------
server <- function(input, output) {
  # INPUT EVENT REACTIONS
  # reconstruct the tree every time createModel is pressed
  tree = eventReactive(
    eventExpr = input$createModel,
    valueExpr = makeTree(
      model_vars = input$model_vars,
      input$min_split, input$min_bucket, input$max_depth
    )
  )
  
  # regenerate training results every time createModel is pressed
  training_results = eventReactive(
    eventExpr = input$createModel,
    valueExpr = useTree(tree(), train_df)
  )
  
  # regenerate test results every time createModel is pressed
  test_results = eventReactive(
    eventExpr = input$testModel,
    valueExpr = useTree(tree(), test_df)
  )
  
  # OUTPUT DISPLAY PREP
  # assessment scores are each collapsed to display on a new line
  output$training_scores = renderText(
    paste(calcScores(training_results()), collapse = "\n")
  )
  output$test_scores = renderText(
    paste(calcScores(test_results()), collapse = "\n")
  )
  
  # tables of outcome breakdows are static widgets
  output$training_table = renderTable(
    resultsTable(training_results()),
    align = "lccc",  # left-align first column, centre rest
    striped = TRUE
  )
  output$test_table = renderTable(
    resultsTable(test_results()),
    align = "lccc",  # left-align first column, centre rest
    striped = TRUE
  )
  # frame for a plot of the decision tree
  output$tree_plot = renderPlot(
    # prp takes an output from rpart and plots it (literally Plot RPart)
    prp(
      tree(), roundint = FALSE,
      # neaten up the nodes and edges, remove detailed labels
      extra = 0, branch = 0, varlen = 0,
      # colours spam terminals in red, non-spam terminals in blue
      box.col = c("cornflowerblue", "tomato")[tree()$frame$yval]
    )
  )
}



# ------- Run the application -------
shinyApp(ui = ui, server = server)
