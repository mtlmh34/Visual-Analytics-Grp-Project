# ISSS608 Visual Analytics and Applications
# Group Project: Hotel Data Analytics Dashboard
# Authors: Liang Minghao, Ashley Choi, Christiana Lim
# Affliated to: Singapore Management University


### --------- Getting Started ---------

pacman:: p_load(shiny, shinythemes, shinyWidgets, 
                tidyverse, gt, gtsummary, 
                parallelPlot, ggplot2, plotly, 
                ggalluvial, gmodels, readxl, DT, ggstatsplot, 
                rpart, rpart.plot, caret, tibble)
set.seed(123)

# loading data
hotel_data <- read_excel('data/hotel_data_merged.xlsx')

hotel_data <- hotel_data %>% 
  mutate(Meal = str_trim(Meal)) %>% 
  select(-Agent,-Company)


# split train and test
data_size=nrow(hotel_data)
index <- sample(1:data_size, size = trunc(.8 * data_size))
train_df <- hotel_data %>%
  filter(row_number() %in% index)

test_df <- hotel_data %>%
  filter(!(row_number() %in% index))

# for decision tree
var_list <- list(
  "No. of Non-Canceled Previous Bookings"="PreviousBookingsNotCanceled", 
  "No. of Previous Cancallations"="PreviousCancellations",  
  "No. of Special Requests"="TotalOfSpecialRequests",
  "No. of Changes Made"="BookingChanges",  
  "Hotel Type"="HotelType",    
  "Customer Type"="CustomerType", 
  "Deposit Type"="DepositType",   
  "Lead Time"="LeadTime",                   
  "Market Segment"="MarketSegment",   
  "Distribution Channel"="DistributionChannel", 
  "Reserved Room Type"="ReservedRoomType", 
  "Assigned Room Type"="AssignedRoomType",
  "Avg. Daily Rate"="ADR",
  "No. of Adults"="Adults",
  "No. of Babies"="Babies",
  "No. of Children"="Children",
  "No. of Days in Waiting List"="DaysInWaitingList",          
  "Is Repeated Guest?"="IsRepeatedGuest",             
  "Required CarParking Spaces?"="RequiredCarParkingSpaces"
)
var_list_default <- var_list[1:9]

# for LR model
lr_var_list <- list(
  "No. of Non-Canceled Previous Bookings"="PreviousBookingsNotCanceled", 
  "No. of Previous Cancallations"="PreviousCancellations",  
  "No. of Special Requests"="TotalOfSpecialRequests",
  "No. of Changes Made"="BookingChanges",  
  "Hotel Type"="HotelType",    
  "Customer Type"="CustomerType", 
  "Deposit Type"="DepositType",   
  "Lead Time"="LeadTime",                   
  "Market Segment"="MarketSegment",   
  "Distribution Channel"="DistributionChannel", 
  "Reserved Room Type"="ReservedRoomType", 
  "Assigned Room Type"="AssignedRoomType",
  "Avg. Daily Rate"="ADR",
  "No. of Adults"="Adults",
  "No. of Babies"="Babies",
  "No. of Children"="Children",
  "No. of Days in Waiting List"="DaysInWaitingList",          
  "Is Repeated Guest?"="IsRepeatedGuest",             
  "Required CarParking Spaces?"="RequiredCarParkingSpaces"
)
lr_var_list_default <- lr_var_list[1:9]



### --------- functions --------
# Train Tree Model
makeTree = function(model_vars, min_split, min_bucket, max_depth) {
  # Takes a list of model variables (strings), a minimum split parameter
  # (int), a minimum bucket size parameter (int), and a maximum tree depth
  # parameter (int) as inputs and then returns an rpart classification tree
  # created with those parameters using Gini-indexes without any pruning.
  
  train_dat = train_df
  # create an rpart compatible formula for the model from the chosen vars
  f = paste("IsCanceled ~ ", paste(model_vars, collapse = " + "))
  # rpart is performs the split calculations and returns the tree
  tree = rpart(
    as.formula(f),
    method = "class",  # sets it up as a classification problem
    data = train_dat,
    parms = list(prior = c(.5,.5), split = "information"),  # ensures rpart uses gini indexes
    minsplit = min_split,
    minbucket = min_bucket,
    maxdepth = max_depth,
    cp = 0  # complexity parameter, at zero prevents pruning on branches
  )
  
  print("tree trained")
  return(tree)
}

# Predict Tree
useTree = function(tree,df) {
  # Takes a tree generated by rpart and a filename (string) as input and
  # then predicts the labels of the data in that file using the tree. It
  # returns a dataframe with two bool (0,1) columns: prediction and truth.
  
  data = df
  prediction = predict(tree, data, type = "class")
  results = as.data.frame(prediction)
  results$truth = data$IsCanceled
  
  print("prediction completed")
  return(results)
}

# Evaluation
calcScores = function(results) {
  
  results = table(results)
  
  # Calculate accuracy
  accuracy <- round((results[1,1]+results[2,2])/sum(results),3)*100
  
  # Calculate precision
  precision <- round(results[2,2]/sum(results[2,]),3)*100
  
  # Calculate recall
  recall <- round(results[2,2]/sum(results[,2]),3)*100
  
  # the collapse argument removes the spacing which would otherwise be there
  return(list(
    paste(c("Overall Accuracy: ",   accuracy, "%"), collapse = ""),
    paste(c("Precision: ", precision, "%"), collapse = ""),
    paste(c("Recall: ", recall, "%"), collapse = "")
  ))
}

# Confusion Matrix
resultsTable = function(results) {

  data = table(results)
  Outcomes = c("Predicted Not Cancelled", "Predicted Cancelled", "Total")
  # reconstruct the columns of R's table(...) CLI display
  c1 = c(data[, 1], sum(data[, 1]))  #TN, FN, Sum(TN, FN)
  c2 = c(data[, 2], sum(data[, 2]))  #FP, TP, Sum(TP, FP)
  c3 = c(sum(data[, 1]), sum(data[2, ]), sum(data))
  
  # turn these columns back into a dataframe but with proper headers
  output = data.frame(Outcomes)
  output$"Actually Not Cancelled" = c1
  output$"Actually Cancelled" = c2
  output$"Total" = c3
  
  return(output)
}

# Corr Heatmap
corrplot_num = function(df){
  df <- na.omit(df)
  numeric_var <- names(df)[sapply(df[names(df)], is.numeric)]
  num_df <- df[, numeric_var[2:length(numeric_var)]]
  
  # calculate the correlation matrix
  corr_mat <- cor(num_df)
  
  # Create correlation heatmap with plotly
  p <- plot_ly(z = corr_mat, type = "heatmap", colorscale = "RdBu", reversescale = TRUE,
          x = colnames(corr_mat), y = colnames(corr_mat)) %>%
    layout(title = "Correlation Heatmap of Numerical Variables",
           xaxis = list(tickangle = 30),
           yaxis = list(showticklabels = FALSE))
  
  print("correlations plotted")
  return(p)
}

# Logistic Regression
makeLR = function(model_vars){
  data = train_df
  
  data[data==""]<-NA
  data[data=="NULL"]<-NA
  
  data$HotelType=as.factor(data$HotelType)  
  data$ArrivalDateMonth=as.factor(data$ArrivalDateMonth)  
  data$Meal=as.factor(data$Meal)  
  data$MarketSegment=as.factor(data$MarketSegment)  
  data$DistributionChannel=as.factor(data$DistributionChannel)  
  data$ReservedRoomType=as.factor(data$ReservedRoomType)  
  data$AssignedRoomType=as.factor(data$AssignedRoomType)  
  data$DepositType=as.factor(data$DepositType)   
  data$CustomerType=as.factor(data$CustomerType)
  
  # create an rpart compatible formula for the model from the chosen vars
  f = paste("IsCanceled ~ ", paste(model_vars, collapse = " + "))
  
  lr_model=glm(as.formula(f),data=data,family=binomial(link="logit"))
  
  print("logistic regression trained")
  return(lr_model)
}

useLR = function(model, df) {
  # Takes a tree generated by rpart and a filename (string) as input and
  # then predicts the labels of the data in that file using the tree. It
  # returns a dataframe with two bool (0,1) columns: prediction and truth.
  
  data = df
  prediction = predict(model, data, type = "response")
  prediction = as.factor(ifelse(prediction>0.5,1,0))
  results = as.data.frame(prediction)
  results$truth = data$IsCanceled

  print("logistic regression predicted")
  return(results)
}

# Plot importance of variables
var_imp_plot = function(varImp){
  
  # calculate variable importance
  varImp <- varImp %>% 
    arrange(desc(Overall)) %>%
    rownames_to_column(var = "Variable") %>%
    slice_head(n = 10)  %>%
    mutate(Variable = str_trim(Variable))

  
  # create a bar chart of the variable importance measures
  p <- plot_ly(data = varImp, y = ~Variable, x = ~Overall, type = "bar", color = "#eab676") %>%
    layout(title = "Variable Importance Measures",
           yaxis = list(
             title = "Predictor Variable",
             categoryorder = "total ascending"),
           xaxis = list(title = "Importance")
    )
  
  print("Importance of variables plotted")
  return(p)
}


# ------- Shiny UI --------

ui <- navbarPage(
  title = "Hotel Data Analytical Dashboard",
  fluid = TRUE,
  theme='simplex',
  id = "navbarID",
  
  tabPanel("User Guide",
           icon = icon('person-chalkboard'),
           h1("Welcome to our App!"),
           mainPanel(
             tags$a(href="https://github.com/mtlmh34/Visual-Analytics-Grp-Project/blob/main/README.md", "Click Here for user guide!")
           )
  ),
  
  ######### Page 1
  navbarMenu("Know Your Customer", 
             icon = icon('briefcase'),
             tabPanel("Rates",
             ),
             tabPanel("Cancellations",
             ),
             tabPanel("Revenue",
             )
  ),
  
  ######### Page 2
  navbarMenu(
    "Know Your Business",
    icon = icon('address-card'),
    tabPanel(
      "Average Booking Price",
      sidebarLayout(
        sidebarPanel(
          h3("ADR Over Time"),
          helpText("The ... plot is used to reveal the timely trend of Average Daily Rate. "),
          br(),
          
          selectInput("hotel_type", "Select Hotel:",
                      choices = c("All", unique(hotel_data$HotelType))),
          # Meal, customer, distribution channel filter
          selectInput("meal", "Meal", choices = c("All", unique(hotel_data$Meal))),
          selectInput("customer_type", "Customer Type", choices = c("All", unique(hotel_data$CustomerType))),
          selectInput("distribution_channel", "Distribution Channel", choices = c("All", unique(hotel_data$DistributionChannel))),
          
          h3("ANOVA Test"),
          helpText("The ANOVA test is used to discover the relationship between the selected variable and the ADR (price). "),
          br(),
          
          # for anova
          selectInput(inputId = "x",
                      label = "Predictor variable:",
                      choices = c("Customer Type" = "CustomerType",
                                  "Hotel Type" = "HotelType",
                                  "Deposit Status" = "DepositType")),
          # insert select for test type 
          radioButtons("y", "Anova Test Type:",
                       c("Non-Parametric" = "np",
                         "Baeyes Factor" = "bf")), 
          submitButton("Apply Changes")
        ), #sidebarpanel
        
        mainPanel(
          # Plot1
          h3('Main title'),
          fluidRow(
            plotOutput("hotel_avr"),
          ),
          fluidRow(
            plotOutput("AnovaPlot")
          )
        ) #mainpanel
      ) #sidebarlayout
    ), #tabpanel
    
    # ------ Tab 2. Filters affecting cancellation rate plot
    
    tabPanel(
      "Cancellation Rate",
      sidebarLayout(
        sidebarPanel(
          
          selectInput("HotelType", "Select Hotel:",
                      choices = c("All", unique(hotel_data$HotelType))),
          
          # Lead time range filter
          sliderInput("LeadTime", "Lead Time Range (Days)", 
                      min = 0, max = max(hotel_data$LeadTime), value = c(0, max(hotel_data$LeadTime))),
          
          # Number of booking changes range filter
          sliderInput("BookingChanges", "Number of Booking Changes", 
                      min = 0, max = max(hotel_data$BookingChanges), value = c(0, max(hotel_data$BookingChanges))),
          
          # Checkbox filter for deposit type
          checkboxGroupInput("DepositType", "Deposit Type", 
                             choices = unique(hotel_data$DepositType), selected = unique(hotel_data$DepositType)),
          
          # Only one option can be selected in the Repeated Guest checkbox
          radioButtons("IsRepeatedGuest", "Repeated Guest",
                       choices = c("All", "Yes", "No"), selected = "All"),
          
          # YYYY-MM filter slicer
          dateRangeInput("YearMonth", "YYYY-MM", 
                         start = as.Date("2015-01-01"), 
                         end = as.Date("2017-09-30"), 
                         format = "yyyy-mm", separator = " - "),
          
          submitButton("Apply Changes")), #sidebarpanel
        
        mainPanel(
          # Plot2
          plotOutput("hotel_cancellation")
          
        ) # mainpanel
      ), # sidebarlayout
    ), # tabpanel
  ), #Page 2
  
  ######### Page 3
  navbarMenu(
    "Predictive Analysis",
    icon = icon("chart-line"),
    tabPanel(
      "Decision Tree: Cancellation Prediction",
      sidebarLayout(
        sidebarPanel(
          h3("The Controls"),
          br(),
          
          actionBttn(
            inputId = "createTreeModel",
            label = "Create Tree",
            class = "primary"  # makes it blue!
          ),
          actionBttn(
            inputId = "testTreeModel",
            label = "Test Tree",
            color = "danger"  # makes it red!
          ),
          
          br(),
          
          h3("Model Features"),
          helpText(
            'Here are the choices of the predictors to choose:'
          ),
          pickerInput(
            inputId = "model_vars",
            label = NULL,  # label given in outer code
            choices = var_list,
            selected = var_list_default,
            options = list(`actions-box` = TRUE),
            multiple = TRUE
          ),
          
          br(),
          "Here are some hyperparameters for tuning the DT: ",
          
          h4("Minimum Split"),
          helpText(
            "Control the minimum size allowed for the node to split further"
          ),
          sliderInput(
            inputId = "min_split",
            label = NULL,  # label given in outer code
            min = 500,       # two is the smallest that could be split
            max = 10000,      # chosen to not make the models too wild
            value = 1000,      # defaults to not having an artifical minimum,
            step=500
          ),
          
          br(),
          
          h4("Minimum Bucket Size"),
          helpText(
            "Control the minimum size allowed in the terminal node"
          ),
          sliderInput(
            inputId = "min_bucket",
            label = NULL,  # label given in outer code
            min = 100,       # can't have buckets of size zero
            max = 3000,      # rpart default is minbucket = 3*minsplit
            value = 500,     # defaults to not having an artifical minimum
            step = 100
          ),
          br(),
          h4("Maximum Tree Depth"),
          helpText(
            "Control the maximum depth that the decision tree can reach"
          ),
          sliderInput(
            inputId = "max_depth",
            label = NULL,  # label given in outer code
            min = 2,       # a min of 2 allows for at least one split
            max = 15,      # rpart can't do 31+ depth on 32-bit machines
            value = 5      # chosen to not make the default too wild
          )
        ), #SidebarPanel
        mainPanel(
          fluidRow(
            label = NULL,
            column(6,
                   h3("Training Results"),
                   br(),
                   # training accuracy, precision, recall
                   tagAppendAttributes(
                     textOutput("tree_training_scores"),
                     # allow linebreaks between scores, larger font here
                     style = "white-space: pre-wrap; font-size: 17px;"
                   ), 
                   # training results table matches layout from presentation
                   tableOutput("tree_training_table")
            ), # column 1
            column(6,
                   h3("Test Results"),
                   br(),
                   # test accuracy, precision, recall
                   tagAppendAttributes(
                     textOutput("tree_test_scores"),
                     # allow linebreaks between scores, larger font here
                     style = "white-space: pre-wrap; font-size: 17px;"
                   ),
                   # training results table matches layout from presentation
                   tableOutput("tree_test_table")
            ) # column 2
          ), # fluidRow
          fluidRow(
            column(8,
                   h3("Decision Tree"),
                   helpText(
                     "Class 0: Predicted not Canceled; Class 1: Predicted Canceled"
                   ),
                   plotOutput(outputId = "tree_plot")
            ), #column 1
            column(4,
                   h3("Classification"),
                   "- The tree graph on the left dicpicts the suggested method by a trained decision tree model,
                                   which classfies whether a customer is likely to cancelled the order. "
                   ,
                   br(),br(),
                   "- The accuracy of the model can be referred by the training and testing accuracy on the top.",
                   br(),br(),
                   "- Operation team can utilise this model as a guide and pay extra attentions to the customer who are likely to churn."
            ) # column 2
          ) #FluidRow
        )#mainPanel
      )#SidebarLayout
    ), #tabPanel 1
    
   tabPanel(
     "Logistic Regression: Cancellation Prediction",
     sidebarLayout(
       sidebarPanel(
         h3("The Controls"),
         br(),
         
         actionBttn(
           inputId = "createLRModel",
           label = "Create Model",
           class = "primary"  # makes it blue!
         ),
         actionBttn(
           inputId = "testLRModel",
           label = "Test Model",
           color = "danger"  # makes it red!
         ),
         
         br(),
         
         h3("Model Features"),
         helpText(
           'Here are the choices of the predictors to choose:'
         ),
         pickerInput(
           inputId = "lr_model_vars",
           label = NULL,  # label given in outer code
           choices = lr_var_list,
           selected = lr_var_list_default,
           options = list(`actions-box` = TRUE),
           multiple = TRUE
         ), 
         
         br(),
         
         h3("Test For Multi-Collinearity"),
         helpText("Below shows the correlations between each of the numerical variables.
                  Highly correlated pairs need to be excluded from the logistic regression model."),
         plotlyOutput(outputId = "num_corr_plot"),
       ),#sidebarPanel
       mainPanel(
         fluidRow(
           label = NULL,
           column(6,
                  h3("Training Results"),
                  br(),
                  # training accuracy, precision, recall
                  tagAppendAttributes(
                    textOutput("lr_training_scores"),
                    # allow linebreaks between scores, larger font here
                    style = "white-space: pre-wrap; font-size: 17px;"
                  ), 
                  # training results table matches layout from presentation
                  tableOutput("lr_training_table")
           ), # column 1
           column(6,
                  h3("Test Results"),
                  br(),
                  # test accuracy, precision, recall
                  tagAppendAttributes(
                    textOutput("lr_test_scores"),
                    # allow linebreaks between scores, larger font here
                    style = "white-space: pre-wrap; font-size: 17px;"
                  ),
                  # training results table matches layout from presentation
                  tableOutput("lr_test_table")
           ) # column 2
         ), # fluidRow
         fluidRow(
           column(6,
                  h3("Importance of Variables"),
                  plotlyOutput("lr_var_importance_bar")
                  ),
           column(6,
                  h3("Make Prediction")
                  )
         )
       )#MainPanel
     )#SidebarLayout
   )#TabPanel
  )#navbarMenu
)#NavbarPage



# ------- server --------
server <- function(input, output) {
  
  filter_data_1 <- reactive({
    hotel_data %>% 
      filter(if (input$hotel_type == "All") TRUE else HotelType == input$hotel_type) %>%
      filter(if (input$meal == "All") TRUE else Meal == input$meal) %>%
      filter(if (input$customer_type == "All") TRUE else CustomerType == input$customer_type) %>%
      filter(if (input$distribution_channel == "All") TRUE else DistributionChannel == input$distribution_channel) %>%
      mutate(ArrivalDateMonthWeek = paste(ArrivalDateMonth, "W", sprintf("%02d", ArrivalDateWeekNumber), sep = "-")) %>%
      mutate(ArrivalDateMonthWeek = paste(ArrivalDateMonth, "W", sprintf("%02d", ArrivalDateWeekNumber), sep = "-")) %>%
      group_by(ArrivalDateYear, ArrivalDateMonth, ArrivalDateMonthWeek) %>%
      summarize(avg_ADR = mean(ADR), sd_ADR = sd(ADR), n = n())
  })
  
  # Filter the data based on user input
  
  filtered_data2 <- reactive({
    hotel_data %>%
      filter(LeadTime >= input$LeadTime[1], LeadTime <= input$LeadTime[2],
             BookingChanges >= input$BookingChanges[1], BookingChanges <= input$BookingChanges[2],
             if (input$IsRepeatedGuest == "All") TRUE else IsRepeatedGuest == (input$IsRepeatedGuest == "Yes"),
             DepositType %in% input$DepositType,
             if (!is.null(input$YearMonth)) ReservationStatusDate >= input$YearMonth[1] & ReservationStatusDate <= input$YearMonth[2])
  })
  
  # cancellation rate based on filtered data
  
  cancellation_rate <- reactive({
    filtered_data2() %>%
      mutate(ArrivalDateMonthWeek = paste(ArrivalDateMonth, "W", sprintf("%02d", ArrivalDateWeekNumber), sep = "-"),
             ReservationStatusYearMonth = format(as.Date(ReservationStatusDate), "%Y-%m")) %>%
      group_by(ReservationStatusYearMonth) %>%
      summarize(CancellationRate = mean(IsCanceled))
  }) 
  
  
  # Tab 1: Average Rate
  # Plot a line chart with upper and lower bound based on YYYY-MM ADR
  
  output$hotel_avr <- renderPlot({
    filter_data_1() %>%
      ggplot(aes(x = factor(ArrivalDateMonth,levels = month.name), y = avg_ADR, color = factor(ArrivalDateYear))) +
      #geom_line() +
      geom_ribbon(aes(ymin = avg_ADR - 1.96 * sd_ADR / sqrt(n), ymax = avg_ADR + 1.96 * sd_ADR / sqrt(n)), alpha = 0.2) +
      scale_color_discrete(name = "Year") +
      labs(x = "Month", y = "Average Daily Rate") +
      ggtitle("Average Daily Rate by Month and Year")
  }) 
  
  
  # Tab 2: Cancellation rate
  # Plot cancellation rate trend
  
  output$hotel_cancellation <- renderPlot({
    cancellation_rate() %>%
      ggplot(aes(x = ReservationStatusYearMonth, y = CancellationRate)) +
      geom_bar(stat = "identity") +
      ggtitle("Hotel Cancellation Rate") +
      xlab("Year and Month") +
      ylab("Cancellation Rate") +
      scale_fill_discrete(name = "Year and Month") +
      theme(axis.text.x = element_text(angle = 90, hjust = 1))
  })
  
  
  # Tab 3: Inferential Analysis
  # Create Anova Plots for ADR means by input
  
  output$AnovaPlot <- renderPlot({
    hotel_data%>%
      ggbetweenstats(!!input$x, y = ADR, xlab = input$x, 
                     type = input$y, 
                     ylab = "ADR", 
                     title = "Differences in means between Average Daily Rate",
                     ggplot.component = list(theme(plot.subtitle = element_text(size = 12, face = "bold"),
                                                   plot.title = element_text(size = 13, face = "bold")))) +
      scale_y_continuous(
        limits = c(0, 1000),
        breaks = seq(from = 0, to = 1000, by = 50)
      )
  }) # AnovaPlot

#---------- TAB 3 ---------------
  
  #------ INPUT EVENT REACTIONS -----
  #------ Decision Tree --------
  # reconstruct the tree every time createModel is pressed
  tree = eventReactive(
    eventExpr = input$createTreeModel,
    valueExpr = makeTree(
      model_vars = input$model_vars,
      input$min_split, input$min_bucket, input$max_depth
    )
  )
  
  # regenerate training results every time createModel is pressed
  tree_training_results = eventReactive(
    eventExpr = input$createTreeModel,
    valueExpr = useTree(tree(), train_df)
  )
  
  # regenerate test results every time createModel is pressed
  tree_test_results = eventReactive(
    eventExpr = input$testTreeModel,
    valueExpr = useTree(tree(), test_df)
  )
  
  #------ Logistic Regresion --------
  lr = eventReactive(
    eventExpr = input$createLRModel,
    valueExpr = makeLR(input$lr_model_vars)
  )
  
  # regenerate training results every time createModel is pressed
  lr_training_results = eventReactive(
    eventExpr = input$createLRModel,
    valueExpr = useLR(lr(), train_df)
  )
  
  # regenerate test results every time createModel is pressed
  lr_test_results = eventReactive(
    eventExpr = input$testLRModel,
    valueExpr = useLR(lr(), test_df)
  )
  
  lr_var_importance = eventReactive(
    eventExpr = input$createLRModel,
    valueExpr = varImp(lr(), scale = FALSE)
  )
  
  #------ OUTPUT DISPLAY PREP ------
  # assessment scores are each collapsed to display on a new line
  output$tree_training_scores = renderText(
    paste(calcScores(tree_training_results()), collapse = "\n")
  )
  output$tree_test_scores = renderText(
    paste(calcScores(tree_test_results()), collapse = "\n")
  )
  
  # tables of outcome breakdows are static widgets
  output$tree_training_table = renderTable(
    resultsTable(tree_training_results()),
    align = "lccc",  # left-align first column, centre rest
    striped = TRUE
  )
  output$tree_test_table = renderTable(
    resultsTable(tree_test_results()),
    align = "lccc",  # left-align first column, centre rest
    striped = TRUE
  )
  # frame for a plot of the decision tree
  output$tree_plot = renderPlot(
    prp(
      tree(), roundint = FALSE,
      # neaten up the nodes and edges, remove detailed labels
      extra = 0, branch = 0, varlen = 0,
      # colours spam terminals in red, non-spam terminals in blue
      box.col = c("cornflowerblue", "tomato")[tree()$frame$yval]
    )
  )
  #correlation heatmap
  output$num_corr_plot = renderPlotly(
    corrplot_num(hotel_data)
  )
  
  output$lr_training_scores = renderText(
    paste(calcScores(lr_training_results()), collapse = "\n")
  )
  output$lr_test_scores = renderText(
    paste(calcScores(lr_test_results()), collapse = "\n")
  )
  
  # tables of outcome breakdows are static widgets
  output$lr_training_table = renderTable(
    resultsTable(lr_training_results()),
    align = "lccc",  # left-align first column, centre rest
    striped = TRUE
  )
  output$lr_test_table = renderTable(
    resultsTable(lr_test_results()),
    align = "lccc",  # left-align first column, centre rest
    striped = TRUE
  )
  
  output$lr_var_importance_bar = renderPlotly(
    var_imp_plot(lr_var_importance())
  )
  
  
  filter_data_1 <- reactive({
    hotel_data %>% 
      filter(if (input$hotel_type == "All") TRUE else HotelType == input$hotel_type) %>%
      filter(if (input$meal == "All") TRUE else Meal == input$meal) %>%
      filter(if (input$customer_type == "All") TRUE else CustomerType == input$customer_type) %>%
      filter(if (input$distribution_channel == "All") TRUE else DistributionChannel == input$distribution_channel) %>%
      mutate(ArrivalDateMonthWeek = paste(ArrivalDateMonth, "W", sprintf("%02d", ArrivalDateWeekNumber), sep = "-")) %>%
      mutate(ArrivalDateMonthWeek = paste(ArrivalDateMonth, "W", sprintf("%02d", ArrivalDateWeekNumber), sep = "-")) %>%
      group_by(ArrivalDateYear, ArrivalDateMonth, ArrivalDateMonthWeek) %>%
      summarize(avg_ADR = mean(ADR), sd_ADR = sd(ADR), n = n())
  })
  
  # Filter the data based on user input
  
  filtered_data2 <- reactive({
    hotel_data %>%
      filter(LeadTime >= input$LeadTime[1], LeadTime <= input$LeadTime[2],
             BookingChanges >= input$BookingChanges[1], BookingChanges <= input$BookingChanges[2],
             if (input$IsRepeatedGuest == "All") TRUE else IsRepeatedGuest == (input$IsRepeatedGuest == "Yes"),
             DepositType %in% input$DepositType,
             if (!is.null(input$YearMonth)) ReservationStatusDate >= input$YearMonth[1] & ReservationStatusDate <= input$YearMonth[2])
  })
  
  # cancellation rate based on filtered data
  
  cancellation_rate <- reactive({
    filtered_data2() %>%
      mutate(ArrivalDateMonthWeek = paste(ArrivalDateMonth, "W", sprintf("%02d", ArrivalDateWeekNumber), sep = "-"),
             ReservationStatusYearMonth = format(as.Date(ReservationStatusDate), "%Y-%m")) %>%
      group_by(ReservationStatusYearMonth) %>%
      summarize(CancellationRate = mean(IsCanceled))
  }) 
  
  
  # Tab 1: Average Rate
  # Plot a line chart with upper and lower bound based on YYYY-MM ADR
  
  output$hotel_avr <- renderPlot({
    filter_data_1() %>%
      ggplot(aes(x = factor(ArrivalDateMonth,levels = month.name), y = avg_ADR, color = factor(ArrivalDateYear))) +
      #geom_line() +
      geom_ribbon(aes(ymin = avg_ADR - 1.96 * sd_ADR / sqrt(n), ymax = avg_ADR + 1.96 * sd_ADR / sqrt(n)), alpha = 0.2) +
      scale_color_discrete(name = "Year") +
      labs(x = "Month", y = "Average Daily Rate") +
      ggtitle("Average Daily Rate by Month and Year")
    
    print("ADR plot")
  }) 
  
  
  # Tab 2: Cancellation rate
  # Plot cancellation rate trend
  
  output$hotel_cancellation <- renderPlot({
    cancellation_rate() %>%
      ggplot(aes(x = ReservationStatusYearMonth, y = CancellationRate)) +
      geom_bar(stat = "identity") +
      ggtitle("Hotel Cancellation Rate") +
      xlab("Year and Month") +
      ylab("Cancellation Rate") +
      scale_fill_discrete(name = "Year and Month") +
      theme(axis.text.x = element_text(angle = 90, hjust = 1))
    
    print("Cancellation plot")
  })
  
  
  # Tab 3: Inferential Analysis
  # Create Anova Plots for ADR means by input
  
  output$AnovaPlot <- renderPlot({
    hotel_data%>%
      ggbetweenstats(!!input$x, y = ADR, xlab = input$x, 
                     type = input$y, 
                     ylab = "ADR", 
                     title = "Differences in means between Average Daily Rate",
                     ggplot.component = list(theme(plot.subtitle = element_text(size = 12, face = "bold"),
                                                   plot.title = element_text(size = 13, face = "bold")))) +
      scale_y_continuous(
        limits = c(0, 1000),
        breaks = seq(from = 0, to = 1000, by = 50)
      )
    
    print("ANOVA plot")
  }) # AnovaPlot
  
  
}



# ------- Run the application -------
shinyApp(ui = ui, server = server)
