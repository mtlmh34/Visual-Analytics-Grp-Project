#
# This is a Shiny web application. You can run the application by clicking
# the 'Run App' button above.
#
# Find out more about building applications with Shiny here:
#
#    http://shiny.rstudio.com/
#

pacman::p_load(shiny, shinythemes, tidyverse, rpart)

set.seed(123)


# loading data
hotel_data <- read.csv('data/hotel.csv')

# split train and test
index <- sample(1:601, size = trunc(.8 * 601))
train_df <- hotel_data %>%
  filter(row_number() %in% index)

test_df <- hotel_data %>%
  filter(!(row_number() %in% index))


### --------- functions
makeTree = function(train_df, model_vars, min_split, min_bucket, max_depth) {
  # Takes a list of model variables (strings), a minimum split parameter
  # (int), a minimum bucket size parameter (int), and a maximum tree depth
  # parameter (int) as inputs and then returns an rpart classification tree
  # created with those parameters using Gini-indexes without any pruning.
  
  train_dat = train_df
  # create an rpart compatible formula for the model from the chosen vars
  f = paste("IsCanceled ~ ", paste(model_vars, collapse = " + "))
  # rpart is performs the split calculations and returns the tree
  tree = rpart(
    as.formula(f),
    method = "class",  # sets it up as a classification problem
    data = train_dat,
    parms = list(split = "gini"),  # ensures rpart uses gini indexes
    minsplit = min_split,
    minbucket = min_bucket,
    maxdepth = max_depth,
    cp = 0  # complexity parameter, at zero prevents pruning on branches
  )
  
  return(tree)
}

useTree = function(tree, test_df) {
  # Takes a tree generated by rpart and a filename (string) as input and
  # then predicts the labels of the data in that file using the tree. It
  # returns a dataframe with two bool (0,1) columns: prediction and truth.
  
  data = test_df
  prediction = predict(tree, data, type = "class")
  results = as.data.frame(prediction)
  results$truth = data$IsCanceled
  
  return(results)
}

calcScores = function(results) {
  # Takes a results dataframe as input and then calculates scores for
  # accuracy, true negative rate, and true positive rate. It returns a
  # list of formatted strings detailing these results.
  
  results = table(results)
  # calculate the scores on which we'll judge our model to 2 decimal places
  accuracy = round(100 * (results[1] + results[4]) / sum(results), 2)
  true_neg = round(100 * results[1] / sum(results[1, ]), 2)
  true_pos = round(100 * results[4] / sum(results[2, ]), 2)
  
  # the collapse argument removes the spacing which would otherwise be there
  return(list(
    paste(c("Overall Accuracy: ",   accuracy, "%"), collapse = ""),
    paste(c("True Positive Rate: ", true_pos, "%"), collapse = ""),
    paste(c("True Negative Rate: ", true_neg, "%"), collapse = "")
  ))
}


resultsTable = function(results) {
  # Takes a results dataframe as input and then reconstructs and returns
  # a dataframe which has a similar layout to the command line interface
  # output of R's table(...) function.
  
  data = table(results)
  Outcomes = c("Predicted Not Cancelled", "Predicted Cancelled", "Total")
  # reconstruct the columns of R's table(...) CLI display
  c1 = c(data[, 1], sum(data[, 1]))  # data[, 1] is a length 2 vector
  c2 = c(data[, 2], sum(data[, 1]))  # data[, 2] is a length 2 vector
  c3 = c(sum(data[, 1]), sum(data[2, ]), sum(data))
  
  # turn these columns back into a dataframe but with proper headers
  output = data.frame(Outcomes)
  output$"Actually Not Cancelled" = c1
  output$"Actually Cancelled"     = c2
  output$"Total"             = c3
  
  return(output)
}



# ------- Shiny UI --------

ui <- navbarPage(
  title = "Hotel Data Analytical Dashboard",
  fluid = TRUE,
  theme='simplex',
  id = "navbarID",
  
  tabPanel("User Guide",
           icon = icon('person-chalkboard'),
           h1("Welcome to our App!"),
           mainPanel(
             tags$a(href="https://github.com/mtlmh34/Visual-Analytics-Grp-Project/blob/main/README.md", "Click Here for user guide!")
             )
           ),
  
  ######### Page 1
  navbarMenu("Know Your Business", 
             icon = icon('briefcase'),
             tabPanel("Rates",
                      ),
             tabPanel("Cancellations",
                      ),
             tabPanel("Revenue by Rank",
                      )
  ),
  
  ######### Page 2
  navbarMenu("Know Your Customers",
             icon = icon('address-card'),
             tabPanel("Demographics",
                      ),
             tabPanel("Preference",
             )
  ),

  ######### Page 3
  navbarMenu("Predictive Analysis", 
             icon = icon("chart-line"),
             tabPanel("Predict For Cancellation: Decision Tree",
                      sidebarLayout(
                        sidebarPanel(
                          h2("The Controls"),
                          br(),
                          
                          actionButton(
                            inputId = "createModel",
                            label = "Create Model",
                            class = "btn-primary"  # makes it blue!
                          ),
                          br(),
                          
                          actionButton(
                            inputId = "testModel",
                            label = "Test Model",
                            class = "btn-danger"  # makes it red!
                          ),
                          
                          br(),
                          
                          h3("Model Features"),
                          helpText(
                            'tryna tune it.......'
                          ),
                          br(),
                          
                          h3("Decision Tree"),
                          helpText(
                            "some text..."
                          ),
                          br(),
                          h4("Minimum Split"),
                          helpText(
                            "If at a given node N is below this value, that node cannot",
                            "be split any further: it is a terminal node of the tree."
                          ),
                          sliderInput(
                            inputId = "min_split",
                            label = NULL,  # label given in outer code
                            min = 2,       # two is the smallest that could be split
                            max = 10,      # chosen to not make the models too wild
                            value = 2      # defaults to not having an artifical minimum
                          ),
                          br(),
                          h4("Minimum Bucket Size"),
                          helpText(
                            "If creating a given split would cause N₁ or N₂ to fall below",
                            "this minimum, then that split isn't made part of the",
                            "decision tree."
                          ),
                          sliderInput(
                            inputId = "min_bucket",
                            label = NULL,  # label given in outer code
                            min = 1,       # can't have buckets of size zero
                            max = 30,      # rpart default is minbucket = 3*minsplit
                            value = 1      # defaults to not having an artifical minimum
                          ),
                          br(),
                          h4("Maximum Tree Depth"),
                          helpText(
                            "Control the maximum depth that the decision tree can reach.",
                            "Note that, depending on what features are being used and the",
                            "values of the other parameters, you may end up with a tree",
                            "much shallower than the maximum."
                          ),
                          sliderInput(
                            inputId = "max_depth",
                            label = NULL,  # label given in outer code
                            min = 2,       # a min of 2 allows for at least one split
                            max = 30,      # rpart can't do 31+ depth on 32-bit machines
                            value = 5      # chosen to not make the default too wild
                          )
                        )
                        ,
                        mainPanel(
                          # contains the goodness assessments data
                          fluidRow(
                            label = NULL,
                            column(6,
                                   h2("Training Results"),
                                   helpText(
                                     " "
                                   ),
                                   # training accuracy, true positive, and true negative
                                   tagAppendAttributes(
                                     textOutput("training_scores"),
                                     # allow linebreaks between scores, larger font here
                                     style = "white-space: pre-wrap; font-size: 17px;"
                                   ),
                                   br(),
                                   # training results table matches layout from presentation
                                   tableOutput("training_table")
                            ),
                            column(6,
                                   h2("Test Results"),
                                   helpText(
                                     ""
                                   ),
                                   # test accuracy, true positive, and true negative
                                   tagAppendAttributes(
                                     textOutput("test_scores"),
                                     # allow linebreaks between scores, larger font here
                                     style = "white-space: pre-wrap; font-size: 17px;"
                                   ),
                                   br(),
                                   # training results table matches layout from presentation
                                   tableOutput("test_table")
                            )
                          ),
                          # plot of the decision tree
                          h2("Decision Tree"),
                          helpText(
                            "This is a graphical depiction of the decision tree, the model",
    
                          ),
                          plotOutput(outputId = "tree_plot"),
                          br(),
                          
                          # contains the tables with inidividal email classifications
                          h3("Training Data"),
                          helpText(
                            "This table contains the training data classifications that",
                            "were produced by the model, as compared to the true labels,",
                            "where 0 is not spam and 1 is spam. The ID matches with the",
                            "row in the",
                            tags$a(
                              # short URL to $(REPO)/blob/master/training-data.csv
                              href = "https://git.io/Jfdgu",
                              "training data"
                            ),
                            "CSV file."
                          ),
                          dataTableOutput("training_data"),
                          h3("Test Data"),
                          dataTableOutput("test_data")
                        )
                      )
                ),
             tabPanel("Predict For Cancellation: Logistic Regression")
             
          )
)
                                       

# ------- server --------
server <- function(input, output) {
  tree = eventReactive(
    eventExpr = input$createModel,
    valueExpr = makeTree(
      model_vars = input$min_split, input$min_bucket, input$max_depth
    )
  )
  # regenerate training results every time createModel is pressed
  training_results = eventReactive(
    eventExpr = input$createModel,
    valueExpr = useTree(tree(), train_df)
  )
  # regenerate test results every time createModel is pressed
  test_results = eventReactive(
    eventExpr = input$testModel,
    valueExpr = useTree(tree(), test_df)
  )
  
  # OUTPUT DISPLAY PREP
  # assessment scores are each collapsed to display on a new line
  output$training_scores = renderText(
    paste(calcScores(training_results()), collapse = "\n")
  )
  output$test_scores = renderText(
    paste(calcScores(test_results()), collapse = "\n")
  )
  
  # tables of outcome breakdows are static widgets
  output$training_table = renderTable(
    resultsTable(training_results()),
    align = "lccc",  # left-align first column, centre rest
    striped = TRUE
  )
  output$test_table = renderTable(
    resultsTable(test_results()),
    align = "lccc",  # left-align first column, centre rest
    striped = TRUE
  )
  
  # frame for a plot of the decision tree
  output$tree_plot = renderPlot(
    # prp takes an output from rpart and plots it (literally Plot RPart)
    prp(
      tree(), roundint = FALSE,
      # neaten up the nodes and edges, remove detailed labels
      extra = 0, branch = 0, varlen = 0,
      # colours spam terminals in red, non-spam terminals in blue
      box.col = c("cornflowerblue", "tomato")[tree()$frame$yval]
    )
  )
}



# ------- Run the application -------
shinyApp(ui = ui, server = server)
